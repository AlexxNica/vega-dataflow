<!DOCTYPE HTML>
<html>
  <head>
    <title>Dataflow Test</title>
    <script src="../build/dataflow.js"></script>
    <style>
      rect { fill: none; stroke-width: 1; shape-rendering: crispEdges; }
      rect#outer { fill: none; stroke: firebrick; }
      rect#inner { fill: none; stroke: steelblue; }
      .hist rect { fill: steelblue; stroke: none; }
    </style>
  </head>
  <body>
    <svg class="hist" width="500" height="100">
      <rect id="b00" x=  "0" y="0" width="24" height="0"></rect>
      <rect id="b10" x= "25" y="0" width="24" height="0"></rect>
      <rect id="b20" x= "50" y="0" width="24" height="0"></rect>
      <rect id="b30" x= "75" y="0" width="24" height="0"></rect>
      <rect id="b40" x="100" y="0" width="24" height="0"></rect>
      <rect id="b50" x="125" y="0" width="24" height="0"></rect>
      <rect id="b60" x="150" y="0" width="24" height="0"></rect>
      <rect id="b70" x="175" y="0" width="24" height="0"></rect>
      <rect id="b80" x="200" y="0" width="24" height="0"></rect>
      <rect id="b90" x="225" y="0" width="24" height="0"></rect>
      <rect id="b01" x="250" y="0" width="24" height="0"></rect>
      <rect id="b11" x="275" y="0" width="24" height="0"></rect>
      <rect id="b21" x="300" y="0" width="24" height="0"></rect>
      <rect id="b31" x="325" y="0" width="24" height="0"></rect>
      <rect id="b41" x="350" y="0" width="24" height="0"></rect>
      <rect id="b51" x="375" y="0" width="24" height="0"></rect>
      <rect id="b61" x="400" y="0" width="24" height="0"></rect>
      <rect id="b71" x="425" y="0" width="24" height="0"></rect>
      <rect id="b81" x="450" y="0" width="24" height="0"></rect>
      <rect id="b91" x="475" y="0" width="24" height="0"></rect>
    </svg><br/>
    <svg width="521" height="421">
      <rect id="outer" x="0" y="0" width="100" height="100"></rect>
      <rect id="inner" x="10" y="10" width="80" height="80"></rect>
    </svg>
    <script type="text/javascript">
console.log('DATAFLOW version', dataflow.version);
data();
layout();

function data() {
  var g = normal(50, 20);
  function gen() {
    var v = -1;
    while (v < 0 || v >= 100) { v = g(); }
    return v;
  }

  function samples(_) {
      return Math.min(Math.max(100,
        _.my <= 100 ? 10000 : (500-(_.my-100))*20), 100000);
  }

  function thresh(_) { return ~~(_.mx/5); }

  function filter(_) {
    var ft = _.ft;
    return function(t) { return t.data < ft; };
  }
  filter.fields = ['data'];

  function bin(t) { return 5 * ~~(t.data / 5); }
  bin.fields = ['data'];

  var df = new dataflow.Dataflow(),
      mx = df.define('mouse-x', 1000),
      my = df.define('mouse-y', 10),
      dn = df.define('N', null, samples, {my:my}),
      ft = df.define('ft', null, thresh, {mx:mx}),
      fv = df.define('filter', null, filter, {ft:ft}),
      dg = df.register(new dataflow.Generator({num:dn, gen:gen})),
      fl = df.register(new dataflow.Filter({test:fv, source:dg})),
      c0 = df.register(new dataflow.Collector()),
      x1 = df.register(new dataflow.Extent({field:'data', source:c0})),
      hg = df.register(new dataflow.Histogram({field:bin})),
      co = df.register(new dataflow.Collector()),
      x2 = df.register(new dataflow.Extent({field:'count', source:co}));

  dg.targets.add(fl);
  fl.targets.add(c0);
  fl.targets.add(hg);
  hg.targets.add(co);
  df.run();
  var len = 0;

  window.addEventListener('mousemove', function(event) {
    var dt = Date.now();

    // HACK until I figure out the 'wiring' strategy
    df._pulse.collector = dg;

    df.update('mouse-x', event.pageX - 20)
      .update('mouse-y', event.pageY - 20)
      .run();
    render();

    dt = Date.now() - dt;
    console.log(dt, dn.value, ft.value, x2.value,
      x1.value
        ? x1.value.map(function(x) { return x.toFixed(2); })
        : null);
  });

  var rects = document.querySelectorAll('.hist > rect');

  function render() {
    var step = 5,
        data = co.value, i, b, h, max=1;
    for (i=0; i<data.length; ++i) {
      if (data[i].count > max) max = data[i].count;
    }
    for (i=0; i<data.length; ++i) {
      b = ~~(data[i].bin / 5);
      h = 100 * data[i].count / max;
      rects[b].setAttribute('height', h);
      rects[b].setAttribute('y', 100 - h);
    }
  }
}

function layout() {
  // Width / Height / Padding example
  function updateWidth(_) {
    return Math.min(Math.max(_.mouseX, _.wMin), _.wMax);
  }
  function updateHeight(_) {
    return Math.min(Math.max(_.mouseY, _.hMin), _.hMax);
  }
  function updateTotalWidth(_) {
    return _.padL + _.w + _.padR;
  }
  function updateTotalHeight(_) {
    return _.padT + _.h + _.padB;
  }

  var df = new dataflow.Dataflow(),
      wMin = df.define('min-width',     100),
      wMax = df.define('max-width',     500),
      hMin = df.define('min-height',     50),
      hMax = df.define('max-height',    400),
      padL = df.define('padding-top',    10),
      padT = df.define('padding-left',   10),
      padR = df.define('padding-right',  10),
      padB = df.define('padding-bottom', 10),
      mx = df.define('mouse-x', 0),
      my = df.define('mouse-y', 0),
      w  = df.define('width',  200, updateWidth,  {mouseX:mx, wMin:wMin, wMax:wMax}),
      h  = df.define('height', 100, updateHeight, {mouseY:my, hMin:hMin, hMax:hMax}),
      tw = df.define('tw', 0, updateTotalWidth, {w:w, padL:padL, padR:padR}),
      th = df.define('th', 0, updateTotalHeight, {h:h, padT:padT, padB:padB});

  var outer = document.querySelector('rect#outer'),
      inner = document.querySelector('rect#inner');

  window.addEventListener('mousemove', function(event) {
    if (!event.buttons) return;
    df.updateAll({
      'mouse-x': event.pageX -  20,
      'mouse-y': event.pageY - 120,
    });
  });

  function render() {
    if (df.run()) {
      outer.setAttribute('width',  tw.value);
      outer.setAttribute('height', th.value);
      inner.setAttribute('x',      padL.value);
      inner.setAttribute('y',      padT.value);
      inner.setAttribute('width',  w.value);
      inner.setAttribute('height', h.value);
    }
    window.requestAnimationFrame(render);
  }
  render();
}

function normal(mean, stdev) {
  mean = mean || 0;
  stdev = stdev || 1;
  var next;
  var f = function() {
    var x = 0, y = 0, rds, c;
    if (next !== undefined) {
      x = next;
      next = undefined;
      return x;
    }
    do {
      x = Math.random()*2-1;
      y = Math.random()*2-1;
      rds = x*x + y*y;
    } while (rds === 0 || rds > 1);
    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform
    next = mean + y*c*stdev;
    return mean + x*c*stdev;
  };
  f.samples = function(n) {
    return gen.zeros(n).map(f);
  };
  f.pdf = function(x) {
    var exp = Math.exp(Math.pow(x-mean, 2) / (-2 * Math.pow(stdev, 2)));
    return (1 / (stdev * Math.sqrt(2*Math.PI))) * exp;
  };
  f.cdf = function(x) {
    // Approximation from West (2009)
    // Better Approximations to Cumulative Normal Functions
    var cd,
        z = (x - mean) / stdev,
        Z = Math.abs(z);
    if (Z > 37) {
      cd = 0;
    } else {
      var sum, exp = Math.exp(-Z*Z/2);
      if (Z < 7.07106781186547) {
        sum = 3.52624965998911e-02 * Z + 0.700383064443688;
        sum = sum * Z + 6.37396220353165;
        sum = sum * Z + 33.912866078383;
        sum = sum * Z + 112.079291497871;
        sum = sum * Z + 221.213596169931;
        sum = sum * Z + 220.206867912376;
        cd = exp * sum;
        sum = 8.83883476483184e-02 * Z + 1.75566716318264;
        sum = sum * Z + 16.064177579207;
        sum = sum * Z + 86.7807322029461;
        sum = sum * Z + 296.564248779674;
        sum = sum * Z + 637.333633378831;
        sum = sum * Z + 793.826512519948;
        sum = sum * Z + 440.413735824752;
        cd = cd / sum;
      } else {
        sum = Z + 0.65;
        sum = Z + 4 / sum;
        sum = Z + 3 / sum;
        sum = Z + 2 / sum;
        sum = Z + 1 / sum;
        cd = exp / sum / 2.506628274631;
      }
    }
    return z > 0 ? 1 - cd : cd;
  };
  f.icdf = function(p) {
    // Approximation of Probit function using inverse error function.
    if (p <= 0 || p >= 1) return NaN;
    var x = 2*p - 1,
        v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),
        a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),
        b = Math.log(1 - (x*x)) / v,
        s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);
    return mean + stdev * Math.SQRT2 * s;
  };
  return f;
}
    </script>
  </body>
</html>